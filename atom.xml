<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林文康的博客</title>
  
  <subtitle>求知欲 + 计划 + 有效方法 + 努力 = 成功</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wenkanglin.com/"/>
  <updated>2018-05-08T16:34:14.000Z</updated>
  <id>http://www.wenkanglin.com/</id>
  
  <author>
    <name>林文康</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js事件的学与记：浏览器环境下注册自定义事件</title>
    <link href="http://www.wenkanglin.com/2018/05/08/js%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.wenkanglin.com/2018/05/08/js事件的学与记：浏览器环境下注册自定义事件/</id>
    <published>2018-05-08T08:54:41.000Z</published>
    <updated>2018-05-08T16:34:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过本文章来了解一下，怎么在浏览器环境下，通过注册自定义事件。一般分为 3 个步骤：</p><ul><li>首先，通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">event</a>或者<a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent" target="_blank" rel="noopener">CustomEvent</a>注册一个自定义事件。</li><li>然后，通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">addEventListener</a>订阅自定义事件。</li><li>最后，通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent" target="_blank" rel="noopener">dispatchEvent</a>触发自定义事件。</li></ul><a id="more"></a><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><blockquote><p>event = new Event(typeArg, eventInit);</p></blockquote><p><code>eventInit</code> 作为一个可选配置对象，有以下三个属性：</p><ul><li><strong>bubbles</strong>：表示事件是否可以冒泡，默认为 false。</li><li><strong>cancelable</strong>：表示事件是否可以被取消掉，默认为 false。可取消的话，则可以使用 <code>preventDefault</code> 阻止默认事件；否则报错。</li><li><strong>composed</strong>：和影子 DOM 有关的选项，不是很了解。默认为 false。</li></ul><p>通过 <code>Event</code> 构造函数实例化一个自定义事件，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> Event(<span class="string">'xiba'</span>);</span><br></pre></td></tr></table></figure><p>当然也可以实例化一个更加具体的 <code>Event</code>，例如 <code>MouseEvent</code>、<code>InputEvent</code>等等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">'xiba'</span>);</span><br></pre></td></tr></table></figure><p>另外，虽然也可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createEvent" target="_blank" rel="noopener">document.createEvent</a>创建一个自定义事件对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvent'</span>);</span><br></pre></td></tr></table></figure><p>但是，必须通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/initEvent" target="_blank" rel="noopener">event.initEvent</a>进行初始化，否则不能触发该自定义事件，报错信息如下：</p><blockquote><p>Uncaught DOMException: Failed to execute ‘dispatchEvent’ on ‘EventTarget’: The event provided is uninitialized.</p></blockquote><p>因为，<code>event.initEvent</code> 处于被弃用的状态，所以不建议使用 <code>document.createEvent</code>。</p><h2 id="CustomEvent"><a href="#CustomEvent" class="headerlink" title="CustomEvent"></a>CustomEvent</h2><blockquote><p>event = new CustomEvent(typeArg, customEventInit);</p></blockquote><p>作为 <code>Event</code> 的一个原型继承的对象，使用方式唯一不太一样的在于 <code>customEventInit</code>，比 <code>Event</code> 多了一个属性：</p><ul><li><strong>detail</strong>：默认为 null，可用于事件的自定义数据，能在事件监听器里面通过 <code>event.detail</code> 访问自定义数据。</li></ul><p>相比于<code>Event</code>，建议通过 <code>CustomEvent</code> 去自定义事件。虽然功能相差不大，但后者无疑更具备语义化。</p><h2 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h2><p>在调用这个方法之前，<strong>必须要订阅自定义事件</strong>，才能确保触发的自定义事件能够被监听到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'test'</span>);</span><br><span class="line">element.addEventListener(<span class="string">'test'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test custom event'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">element.dispatchEvent(event);</span><br></pre></td></tr></table></figure><p><code>dispatchEvent</code> 的返回值是一个布尔值，表示是否已经触发。如果触发的事件 <code>cacelable</code> 为 true，并且执行监听事件时，执行了 <code>preventDefault</code>，那么 <code>dispatchEvent</code> 的返回值为 false；否则为 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cancelled = !element.dispatchEvent(event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'event cancelled'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'event not cancelled'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Event</a><br> <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent</a><br> <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent</a><br> <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过本文章来了解一下，怎么在浏览器环境下，通过注册自定义事件。一般分为 3 个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;event&lt;/a&gt;或者&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CustomEvent&lt;/a&gt;注册一个自定义事件。&lt;/li&gt;
&lt;li&gt;然后，通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;addEventListener&lt;/a&gt;订阅自定义事件。&lt;/li&gt;
&lt;li&gt;最后，通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dispatchEvent&lt;/a&gt;触发自定义事件。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript，js事件的学与记" scheme="http://www.wenkanglin.com/categories/javascript%EF%BC%8Cjs%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="js事件" scheme="http://www.wenkanglin.com/tags/js%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>js事件的学与记：使用观察者模式实现自定义事件</title>
    <link href="http://www.wenkanglin.com/2018/05/08/js%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.wenkanglin.com/2018/05/08/js事件的学与记：使用观察者模式实现自定义事件/</id>
    <published>2018-05-08T02:55:09.000Z</published>
    <updated>2018-05-08T08:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式（发布-订阅者模式），应该不用多说，使用场景应该说是无处不在的。如 <code>addEventListener</code>，又如 Node.js 中的 <code>EventEmitter</code>，还有 Vue 中数据更新驱动视图更新的原理，都是基于这个模式去实现的。</p><p>那么，自己通过观察者模式怎么去实现呢？这也是在经历面试过程中，经常会被面试官问到的。</p><a id="more"></a><p>自定义事件的功能，一般也要包括以下几个功能：</p><ul><li>事件订阅功能 on。</li><li>事件发布功能 emit。</li><li>事件取消订阅功能 off。</li><li>事件单次订阅功能 once。</li></ul><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/1zsqd2tt/embedded/js/dark" frameborder="0" allowfullscreen></iframe><p>上面示例的代码，原理很简单。用一个对象 <code>storage</code> 存储当下所有的事件名称和事件监听器。每一种事件类型，都将作为这个对象的 key 值，即属性名，属性值是数组，存储每一个事件类型下的所有事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观察者模式（发布-订阅者模式），应该不用多说，使用场景应该说是无处不在的。如 &lt;code&gt;addEventListener&lt;/code&gt;，又如 Node.js 中的 &lt;code&gt;EventEmitter&lt;/code&gt;，还有 Vue 中数据更新驱动视图更新的原理，都是基于这个模式去实现的。&lt;/p&gt;
&lt;p&gt;那么，自己通过观察者模式怎么去实现呢？这也是在经历面试过程中，经常会被面试官问到的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wenkanglin.com/categories/javascript/"/>
    
      <category term="js事件的学与记" scheme="http://www.wenkanglin.com/categories/javascript/js%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
      <category term="面试题" scheme="http://www.wenkanglin.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="js面试题的学与记" scheme="http://www.wenkanglin.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="js事件" scheme="http://www.wenkanglin.com/tags/js%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="js面试题" scheme="http://www.wenkanglin.com/tags/js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DOM对象的学与记：innerHTML、innerText、outerHTML、outerText</title>
    <link href="http://www.wenkanglin.com/2018/05/07/dom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9Ainnerhtml%E3%80%81innertext%E3%80%81outerhtml%E3%80%81outertext/"/>
    <id>http://www.wenkanglin.com/2018/05/07/dom对象的学与记：innerhtml、innertext、outerhtml、outertext/</id>
    <published>2018-05-07T03:17:59.000Z</published>
    <updated>2018-05-08T08:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>一对 inner，一对 outer，长得差不多。其实还算不会那么容易搞混，根据名称就能猜出大概的用途了吧。作为基础的知识点，这里做一个详细的笔记~~</p><p>四者都可读可写，读的是当前节点或文本的内容，写的是覆盖当前节点或文本的内容。一个 inner，一个 outer，前者表示只对当前元素内部的节点或文本进行读写，不包括自身；后者则包括自身。</p><a id="more"></a><h2 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h2><p>获取 body 下所有子节点内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlContent = <span class="built_in">document</span>.body.innerHTML;</span><br></pre></td></tr></table></figure><p>覆盖&amp;设置 body 下所有子节点内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'&lt;div&gt;hello world&lt;/div&gt;'</span>;</span><br></pre></td></tr></table></figure><p>用在读的操作时，则会返回当前元素所有的子节点内容，包括文本节点、元素节点，注释节点等。但返回的并不是一组集合对象，而是解析完之后的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">document</span>.body.innerHTML); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>用在写的操作时，具体的经历步骤如下：</p><ul><li>获取写入的字符串，并解析成 HTML 或 XML，最终生成一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">DocumentFragment</a>。</li><li>若写入的字符串是一个 <code>&lt;template&gt;</code> 元素，那么使用 <code>&lt;template&gt;</code> 属性 <code>content</code> 的值作为 <code>DocumentFragment</code> 的内容，并最终用于目标元素的内容。</li><li>对于其他情况，将使用 <code>DocumentFragment</code> 的内容作为目标元素的内容。</li></ul><p>发现 <code>innerHTML</code> 不太容易报错吧，耐艹，下面的代码都能够正常运行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以写入文本节点</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'some test'</span>;</span><br><span class="line"><span class="comment">// 可以写入自定义标签。IE 浏览器可能会有问题</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'&lt;test&gt;some test content&lt;/test&gt;'</span>;</span><br><span class="line"><span class="comment">// 可以写入非正常闭合的标签</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'&lt;/p&gt;some test content&lt;/p&gt;'</span>;</span><br><span class="line"><span class="comment">// 可以写入子元素的内容，或者父元素的内容</span></span><br><span class="line"><span class="built_in">document</span>.body.innnerHTML = element.innerHTML;</span><br></pre></td></tr></table></figure><p>如果插入的不是一个字符串类型，会自动通过 <code>toString</code> 方法进行隐式转换，例如插入一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = obj;</span><br><span class="line"><span class="comment">// 应该等价于</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = obj.toString();</span><br></pre></td></tr></table></figure><p>可以插入一个空字符串，起到清空元素内容的作用；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空 body 元素的内容</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</span><br></pre></td></tr></table></figure><p>最后，并不需要担心类似于 <code>xss</code> 的安全问题，即使写入一段脚本代码，最后也不会执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'&lt;script&gt;window.alert(234);&lt;/script&gt;'</span>;</span><br></pre></td></tr></table></figure><h2 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h2><p>和 <code>innerHTML</code> 不同的是，写入的是一段文本节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerText = <span class="string">'some text content'</span>;</span><br></pre></td></tr></table></figure><p>即使，写入的字符串是一段元素内容，但最终也会被转化，所以也不用担心安全方面的问题，很适合于显示评论内容的使用场景。下面示例在页面中将会显示包括标签的文本内容，而不是解析成段落。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerText = <span class="string">'&lt;p&gt;hello world&lt;/p&gt;'</span>;</span><br></pre></td></tr></table></figure><h2 id="outerHTML"><a href="#outerHTML" class="headerlink" title="outerHTML"></a>outerHTML</h2><p>和 <code>innerHTML</code> 不同的是，写入的字符串会最终作用于元素本身，即包括元素本身，都会被替换掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 标签本身也会被替换成 div</span></span><br><span class="line">p.outerHTML = <span class="string">'&lt;div&gt;some div...&lt;/div&gt;'</span>;</span><br></pre></td></tr></table></figure><p>可用做删除元素本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.outerHTML = <span class="string">''</span>; <span class="comment">// 删除p元素</span></span><br></pre></td></tr></table></figure><p>如果元素不存在父元素，那么使用 <code>outerHTML</code>，将会抛出异常：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">div.outerHTML = <span class="string">'hello world'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Uncaught DOMException: Failed to set the ‘outerHTML’ property on ‘Element’: This element has no parent node.</p></blockquote><p>另外，需要额外注意的是，<strong>被替换后，变量本身指向的元素属性，都还是之前的元素属性，并不会更新</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.outerHTML = <span class="string">'&lt;div&gt;some content&lt;/div&gt;'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.nodeName); <span class="comment">// P，而不是 DIV</span></span><br></pre></td></tr></table></figure><h2 id="outerText"><a href="#outerText" class="headerlink" title="outerText"></a>outerText</h2><p>不是一个标准的 api。用在读取的操作时，返回值同 <code>innerText</code>，并没有差别。用在写的操作时，包括元素本身被替换成所设置的文本内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p.outerText); <span class="comment">// 结果同p.innerText</span></span><br><span class="line">p.outerText = <span class="string">'some text'</span>;</span><br></pre></td></tr></table></figure><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML</a><br> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText</a><br> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML</a><br> <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一对 inner，一对 outer，长得差不多。其实还算不会那么容易搞混，根据名称就能猜出大概的用途了吧。作为基础的知识点，这里做一个详细的笔记~~&lt;/p&gt;
&lt;p&gt;四者都可读可写，读的是当前节点或文本的内容，写的是覆盖当前节点或文本的内容。一个 inner，一个 outer，前者表示只对当前元素内部的节点或文本进行读写，不包括自身；后者则包括自身。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wenkanglin.com/categories/javascript/"/>
    
      <category term="DOM对象的学与记" scheme="http://www.wenkanglin.com/categories/javascript/dom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="DOM对象" scheme="http://www.wenkanglin.com/tags/dom%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>js事件的学与记：addEventListener</title>
    <link href="http://www.wenkanglin.com/2018/05/06/js%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9Aaddeventlistener/"/>
    <id>http://www.wenkanglin.com/2018/05/06/js事件的学与记：addeventlistener/</id>
    <published>2018-05-06T13:34:34.000Z</published>
    <updated>2018-05-08T08:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说，<code>addEventListener</code> 是一个非常常用的 api，可能也都不陌生。但今天补知识点的时候，发现并没有掌握的非常全面。所以，这里我要好好的补一补关于它的知识点了。</p><a id="more"></a><p>使用语法：</p><blockquote><p>target.addEventListener(type, listener[, options]);<br>target.addEventListener(type, listener[, useCapture]);</p></blockquote><p>接下来，我将详细地对 listener 和 options 进行说明。</p><h2 id="listener-监听器"><a href="#listener-监听器" class="headerlink" title="listener 监听器"></a>listener 监听器</h2><p>使用过 <code>addEventListener</code> 的人会觉得这有什么好说的，不就是一个回调函数吗？之前我也是这么觉得，但今天补完相关知识点之后，才发现 listener 还有一种用法。</p><p>listener 这个参数可以有以下几种形式：</p><ul><li>函数类型。大家用的比较多的回调函数。</li><li>对象类型。是的，没错，可以是一个对象，如空对象。但重点是，如果该对象实现了<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventListener" target="_blank" rel="noopener">EventListner</a>接口，也是可以正常的注册监听事件的。</li><li>null 值，即可以为空。</li></ul><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/y0n69wtL/embedded/js,html,result/dark" frameborder="0" allowfullscreen></iframe><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><p>根据上面的使用语法，第三个参数可以是 useCapture，一个布尔值，表示是否在事件捕获阶段触发事件，默认值为 false，即默认在事件冒泡阶段触发事件。</p><p>除此之外，第三个参数还可以是一个详细的选项 options，一个对象，其中可供选择的属性有：</p><ul><li><strong>capture</strong>，作用同 useCapture。</li><li><strong>once</strong>，一个布尔值，表示注册的监听事件 listener 是否只执行一次，执行一次后被注销，默认为 false。</li><li><strong>passive</strong>，一个布尔值，表示是否禁用 <code>event.preventDefault()</code>。默认值为 false。如果值为 true，并且监听事件内部调用了 <code>preventDefault</code>，那么将会发出警告。</li></ul><p>前面两个选项比较容易理解，这里重点说明一下 <code>passive</code>，以及它的作用。</p><p>总结一句话，<code>passive</code> 的作用是<strong>提升页面滑动的流畅度</strong>。如果我们在 touchstart 事件调用 <code>preventDefault</code> 会怎样呢？这时页面会禁止，不会滚动或缩放。那么问题来了：浏览器无法预先知道一个监听器会不会调用 <code>preventDefault</code>，它需要等监听器执行完后，再去执行默认行为，而监听器执行是要耗时的，这样就会导致页面卡顿。</p><blockquote><p>当你触摸滑动页面时，页面应该跟随手指一起滚动。而此时你绑定了一个 touchstart 事件，你的事件大概执行 200 毫秒。这时浏览器就犯迷糊了：如果你在事件绑定函数中调用了 preventDefault，那么页面就不应该滚动，如果你没有调用 preventDefault，页面就需要滚动。但是你到底调用了还是没有调用，浏览器不知道。只能先执行你的函数，等 200 毫秒后，绑定事件执行完了，浏览器才知道，“哦，原来你没有阻止默认行为，好的，我马上滚”。此时，页面开始滚。</p></blockquote><p>而且 Chrome 做了统计：</p><blockquote><p>在 Android 版 Chrome 浏览器的 touch 事件监听器的页面中，80% 的页面都不会调用 preventDefault 函数来阻止事件的默认行为。在滑动流畅度上，有 10% 的页面增加至少 100ms 的延迟，1% 的页面甚至增加 500ms 以上的延迟。</p></blockquote><p>也就是说，当浏览器等待执行事件的默认行为时，大部分情况是白等了。如果 Web 开发者能够提前告诉浏览器：“我不调用 preventDefault 函数来阻止事件事件行为”，那么浏览器就能快速生成事件，从而提升页面性能。</p><p>这也正是 <code>passive</code> 的作用。我们可以通过传递 <code>passive</code> 为 true 来明确告诉浏览器，事件处理程序不会调用 <code>preventDefault</code> 来阻止默认滑动行为。</p><p>在 Chrome 浏览器中，如果发现耗时超过 100 毫秒的非 <code>passive</code> 的监听器，会在 DevTools 里面警告你设置 <code>{ passive: true }</code>。</p><p>对于那些不支持 <code>passive</code>，或者只支持第三个参数为布尔类型的浏览器来说，如果冒然设置第三个参数为 <code>options</code> 对象格式的话，会隐式的把它转换为 true，即 <code>useCapture</code> 为 true。这可能不是我们想要看到的，所以可以通过以下这段代码，做一个 polyfill：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> supportPassive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> opts = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'passive'</span>, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      supportPassive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'testPassive'</span>, <span class="literal">null</span>, opts);</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'testPaiive'</span>, <span class="literal">null</span>, opts);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line"></span><br><span class="line">target.addEventListener(</span><br><span class="line">  <span class="string">'touchstart'</span>,</span><br><span class="line">  handler,</span><br><span class="line">  supportPassive ? &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125; : <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的代码原理是：如果浏览器支持第三个参数为 <code>options</code> 对象格式的话，在注册自定义事件 <code>testPassive</code>时，那么肯定会读取参数 <code>opts</code> 中的 <code>passive</code> 属性，那么就会触发预先设置好的 <code>getter</code>，使得 <code>supportPassive = true</code>。这样的话，就可以判断浏览器是否支持 <code>passive</code> 了。</p><h2 id="注册多个事件"><a href="#注册多个事件" class="headerlink" title="注册多个事件"></a>注册多个事件</h2><p>相比较于用 <code>on + eventType</code> 的形式来全局注册事件，例如 <code>onClick</code>，<code>addEventListener</code> 的好处是可以对同一个事件类型注册多个事件监听器。另外，<strong>重复注册一个相同的事件监听器，也只会执行一次</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'page clicked'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然下面注册了两次click事件，但由于事件监听器handler是同一个，所以只会执行一次。</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, handler);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, handler);</span><br></pre></td></tr></table></figure><h2 id="事件注销"><a href="#事件注销" class="headerlink" title="事件注销"></a>事件注销</h2><blockquote><p>target.removeEventListener(type, listener[, options]);<br>target.removeEventListener(type, listener[, useCapture]);</p></blockquote><p>可以通过 <code>removeEventListener</code> 来注销之前注册的监听事件，但需要满足以下三点条件，才能成功注销事件：</p><ul><li>target 必须存在，并且之前注册过这种类型的事件。</li><li>需要被删除的 listener 事件监听器必须和注册的事件监听器是同一个。这种情况下，需要把之前注册的事件存储为一个变量，否则直接使用匿名函数，肯定不是同一个事件监听器。</li><li>如果注册事件的同时设置了 <code>useCapture</code> 或者 <code>options</code>，那么注销事件时，也必须带上相同的这些参数，否则将不会注销成功。</li></ul><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener</a><br> <a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md" target="_blank" rel="noopener">https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md</a><br> <a href="https://zhuanlan.zhihu.com/p/24555031" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24555031</a><br></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，&lt;code&gt;addEventListener&lt;/code&gt; 是一个非常常用的 api，可能也都不陌生。但今天补知识点的时候，发现并没有掌握的非常全面。所以，这里我要好好的补一补关于它的知识点了。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wenkanglin.com/categories/javascript/"/>
    
      <category term="js事件的学与记" scheme="http://www.wenkanglin.com/categories/javascript/js%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="js事件" scheme="http://www.wenkanglin.com/tags/js%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>js事件的学与记：事件捕获和事件冒泡</title>
    <link href="http://www.wenkanglin.com/2018/05/06/js%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"/>
    <id>http://www.wenkanglin.com/2018/05/06/js事件的学与记：事件捕获和事件冒泡/</id>
    <published>2018-05-06T07:53:33.000Z</published>
    <updated>2018-05-08T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候，或者自我基础总结的时候，经常会遇到以下的问题：</p><ul><li>什么是事件捕获和事件冒泡？</li><li>事件捕获和事件冒泡顺序的优先级？</li><li>事件捕获和事件冒泡的使用场景是什么？</li><li>事件捕获单独的使用场景是什么？为什么会同时存在这两种事件传播的机制？</li></ul><a id="more"></a><h2 id="事件流程"><a href="#事件流程" class="headerlink" title="事件流程"></a>事件流程</h2><p>在说到事件捕获和冒泡前，我们需要先了解一个事件的触发到底经历了哪些？</p><p><img src="/images/eventflow.jpg" alt="事件触发流程"></p><p>如上图所示，一般事件触发的流程会经历这三个阶段：</p><ul><li><strong>捕获阶段</strong>。事件对象通过目标的祖先从页面根元素传播到事件目标的父节点。</li><li><strong>目标阶段</strong>。事件对象到达事件目标的阶段，即 <code>event.target</code>。如果事件不冒泡，那么事件对象将在此阶段完成后停止。</li><li><strong>冒泡阶段</strong>。事件对象以捕获阶段相反的顺序，从目标的父节点开始，向上传播到页面根元素结束。</li></ul><p>在事件触发的过程中，我们也可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase" target="_blank" rel="noopener">Event.eventPhase</a>来得到当前事件执行的阶段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'current pahse:'</span>, event.eventPhase);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到这里为止，我们应该知道了一开始问题一的事件捕获和事件冒泡是啥了，它们用相反的事件传播顺序触发事件流。而且，根据上面的三个阶段，也应该知道问题二的答案。</p><blockquote><p>问题：事件捕获和事件冒泡顺序的优先级？<br><br>答案：先经历事件捕获，再经历事件冒泡。</p></blockquote><h2 id="设置事件触发的阶段"><a href="#设置事件触发的阶段" class="headerlink" title="设置事件触发的阶段"></a>设置事件触发的阶段</h2><p>我们可以通过 <code>addEventListener</code> 绑定一个事件，并决定事件是在捕获阶段触发呢，还是在冒泡阶段触发。默认是冒泡阶段触发，可通过设置第三个参数为 <code>true</code> 来设置事件在捕获阶段触发。</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/xvbevmj5/embedded/js,html,css,result/dark" frameborder="0" allowfullscreen></iframe><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(type, handler, useCapture);</span><br><span class="line">addEventListener(type, handler, &#123; capture &#125;);</span><br></pre></td></tr></table></figure><p>另外，<strong>阻止事件捕获和冒泡</strong>，都可以通过 <code>event.stopPropagation()</code> 来达到阻止的效果。正确来说，若处于事件捕获阶段，然后调用它，那么事件流将在目标阶段结束，而不会执行事件冒泡的流程。若处于事件冒泡阶段，然后调用它，那么将阻止事件继续向上冒泡的过程。</p><h2 id="事件代理或事件委托"><a href="#事件代理或事件委托" class="headerlink" title="事件代理或事件委托"></a>事件代理或事件委托</h2><p>事件代理和事件委托指的是同一个玩意，是一个很常见的事件冒泡使用场景。而且由于作为一个典型的事件性能优化手段，可供参考的资料有很多。所以，这里不做具体的描述。一个字，懒 -_-||。</p><h2 id="事件捕获的使用场景"><a href="#事件捕获的使用场景" class="headerlink" title="事件捕获的使用场景"></a>事件捕获的使用场景</h2><p>接下来，我们重点讨论一下事件捕获的使用场景，这也是为什么为同时存在捕获和冒泡两种事件传播方式的原因吧。</p><p>个人目前想的到的使用场景主要有以下两个：</p><ul><li>一个是<strong>非冒泡事件的事件代理</strong>。类似于 <code>focus</code>、<code>blur</code>、<code>mouseenter</code>等不能冒泡的事件类型，不能通过基于事件冒泡的事件代理方式来处理。那么可以通过基于事件捕获的事件代理来处理。但是，个人经验有限，实在是想不出具体实际的场景。</li><li>因为事件捕获阶段先于事件冒泡阶段，那么是不是可以在事件捕获阶段，充当一个拦截器，或过滤器的作用，当满足条件时，才继续执行事件冒泡阶段。这样的话，具体的判断逻辑放在事件捕获阶段，具体的事件处理逻辑放在事件冒泡阶段，职责分明，充当不同的角色。</li></ul><p>至于，为什么会同时存在这两种事件传播的机制？这个问题撇开使用场景这方面原因，更多的应该是历史发展的原因。当初 Netscape Navigator 4 的事件传播方式是近似于事件捕获，而 IE 4 的正相反。最后，W3C DOM 标准，从设计思路上是更接近 IE 的设计的，即事件冒泡，只是加入了事件捕获阶段。</p><h2 id="其它一些补充"><a href="#其它一些补充" class="headerlink" title="其它一些补充"></a>其它一些补充</h2><p>上面讲到“非冒泡事件”，那么怎么来判断一个事件能否冒泡呢？答案是可通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/bubbles" target="_blank" rel="noopener">event.bubbles</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input.addEventListener(<span class="string">'focus'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// focus事件不能冒泡</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.bubbles); <span class="comment">// false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>event.stopPropagation()</code> 方法兼容 <code>IE9+</code>，低于这个版本的 IE 浏览器，应使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/cancelBubble" target="_blank" rel="noopener">event.cancelBubble</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">el.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> event.stopPropagation === <span class="string">'function'</span>) &#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><blockquote><p><a href="http://javascript.info/bubbling-and-capturing" target="_blank" rel="noopener">http://javascript.info/bubbling-and-capturing</a><br> <a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture" target="_blank" rel="noopener">https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试的时候，或者自我基础总结的时候，经常会遇到以下的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是事件捕获和事件冒泡？&lt;/li&gt;
&lt;li&gt;事件捕获和事件冒泡顺序的优先级？&lt;/li&gt;
&lt;li&gt;事件捕获和事件冒泡的使用场景是什么？&lt;/li&gt;
&lt;li&gt;事件捕获单独的使用场景是什么？为什么会同时存在这两种事件传播的机制？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wenkanglin.com/categories/javascript/"/>
    
      <category term="js事件的学与记" scheme="http://www.wenkanglin.com/categories/javascript/js%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
      <category term="面试题" scheme="http://www.wenkanglin.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="js面试题的学与记" scheme="http://www.wenkanglin.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/js%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="js事件" scheme="http://www.wenkanglin.com/tags/js%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="js面试题" scheme="http://www.wenkanglin.com/tags/js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>DOM对象的学与记：NodeList和HTMLCollection</title>
    <link href="http://www.wenkanglin.com/2018/05/05/dom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9Anodelist%E5%92%8Chtmlcollection/"/>
    <id>http://www.wenkanglin.com/2018/05/05/dom对象的学与记：nodelist和htmlcollection/</id>
    <published>2018-05-05T03:08:03.000Z</published>
    <updated>2018-05-08T08:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>NodeList</code> 是一系列页面节点的集合，相比较于 <code>HTMLCollection</code> 的一系列页面元素的集合，从它们字面上的含义也都可以看出两者的不同。前者节点不仅仅包括元素节点，还包括文本节点、属性节点、注释节点等，而后者只包括元素节点。</p><a id="more"></a><p>也就是说，<code>NodeList</code> 的每一项都是 <code>Node</code> 对象类型，而 <code>HTMLCollection</code> 的每一项是 <code>HTMLElement</code> 对象类型。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childNodes = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"><span class="keyword">const</span> children = <span class="built_in">document</span>.body.children;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(childNodes <span class="keyword">instanceof</span> NodeList); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(children <span class="keyword">instanceof</span> HTMLCollection); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(childNodes.item(<span class="number">0</span>) <span class="keyword">instanceof</span> Node); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(children.item(<span class="number">0</span>) <span class="keyword">instanceof</span> HTMLElement); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>一般来说，判断节点的类型，是通过节点的 <code>nodeType</code> 属性来判断，常用的节点类型有：</p><table><thead><tr><th>节点类型</th><th>nodeType的值</th><th>常量</th></tr></thead><tbody><tr><td>元素节点</td><td>1</td><td>Node.ELEMENT_NODE</td></tr><tr><td>属性节点</td><td>2</td><td>Node.ATTRIBUTE_NODE</td></tr><tr><td>文本节点</td><td>3</td><td>Node.TEXT_NODE</td></tr><tr><td>注释节点</td><td>8</td><td>Node.COMMENT_NODE</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body.nodeType === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body.nodeType === Node.ELEMENT_NODE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="NodeList-和-HTMLCollection的相似点"><a href="#NodeList-和-HTMLCollection的相似点" class="headerlink" title="NodeList 和 HTMLCollection的相似点"></a>NodeList 和 HTMLCollection的相似点</h2><ul><li>类数组数据结构类型，都可通过 <code>length</code> 获取集合的长度。</li><li>都可通过数组下标的形式，或者 <code>item</code> 来获取集合的某一项。并且，数组下标若为负数或超过集合长度，那么返回 <code>undefined</code>；相同情况下，通过 <code>item</code> 访问返回 <code>null</code>。</li></ul><p>类数组结构，可通过一系列方式使用数组遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childNodes = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"><span class="keyword">const</span> children = <span class="built_in">document</span>.body.children;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过es6的Array.from，转化为数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(childNodes);</span><br><span class="line"><span class="built_in">Array</span>.from(children)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过es6的数组解构赋值，转化为数组</span></span><br><span class="line">[...childNodes];</span><br><span class="line">[...children];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过apply或call</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(childNodes, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(children, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>都可通过数组下标或者 <code>item</code> 来访问集合的某一项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(childNodes[<span class="number">-1</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(children[<span class="number">-1</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(childNodes.item(childNodes.length + <span class="number">1</span>)); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(children.item(<span class="number">-1</span>)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h2 id="NodeList-和-HTMLCollection的不同点"><a href="#NodeList-和-HTMLCollection的不同点" class="headerlink" title="NodeList 和 HTMLCollection的不同点"></a>NodeList 和 HTMLCollection的不同点</h2><ul><li>开头讲到的，<code>NodeList</code> 集合包括所有的节点，即包括了元素。</li><li><code>NodeList</code>虽然是类数组，但本身支持 <code>forEach</code>, <code>keys</code>, <code>values</code>, <code>entries</code>方法。</li><li><code>HTMLCollection</code> 有一个 <code>namedItem</code> 的方法，参数为字符串，用于查找集合中存在元素的 <code>id</code> 和字符串相等的元素。</li></ul><p><code>NodeList</code> 中的 <code>keys</code>, <code>values</code>, <code>entries</code>方法，返回的是一个迭代器，这和数组的方法不太一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childNodes = docuemnt.body.childNodes;</span><br><span class="line"></span><br><span class="line">childNodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> <span class="built_in">console</span>.log(node));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for...of遍历迭代器，或者next</span></span><br><span class="line"><span class="comment">// key是无符号的整数，0....n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> childNodes.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> childNodes.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>namedItem</code> 方法，在 MDN 中解释是：</p><blockquote><p>Returns the specific node whose ID or, as a fallback, name matches the string specified by name. Matching by name is only done as a last resort, only in HTML, and only if the referenced element supports the name attribute. Returns null if no node exists by the given name.</p></blockquote><p>上面描述中，不但可以通过元素的 <code>id</code> 来查找，也可以通过 <code>name</code> 属性来查找，前提是元素支持该属性。然而，本人亲自在 chrome 浏览器中试了一下，查找支持 <code>name</code> 属性的 <code>input</code>，不起作用。可能是不同浏览器存在差异性。</p><p>另外，<code>namedItem</code> 方法返回的结果在不同的浏览器下也存在<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection#Browser_compatibility" target="_blank" rel="noopener">差异性</a>。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/NodeList</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;NodeList&lt;/code&gt; 是一系列页面节点的集合，相比较于 &lt;code&gt;HTMLCollection&lt;/code&gt; 的一系列页面元素的集合，从它们字面上的含义也都可以看出两者的不同。前者节点不仅仅包括元素节点，还包括文本节点、属性节点、注释节点等，而后者只包括元素节点。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wenkanglin.com/categories/javascript/"/>
    
      <category term="DOM对象的学与记" scheme="http://www.wenkanglin.com/categories/javascript/dom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="DOM对象" scheme="http://www.wenkanglin.com/tags/dom%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>html-meta的学与记：format-detection</title>
    <link href="http://www.wenkanglin.com/2018/05/03/html-meta%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9Aformat-detection/"/>
    <id>http://www.wenkanglin.com/2018/05/03/html-meta的学与记：format-detection/</id>
    <published>2018-05-03T08:41:20.000Z</published>
    <updated>2018-05-08T08:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做移动端页面的过程中，可能都遇到过 <code>moble safari</code> 会自动识别一串数字为电话号码，并自动生成拨号的链接。如下图所示：</p><p><img src="/images/telephone-no.jpg" alt="拨号链接"></p><a id="more"></a><p>这可能并不是我们所期望的，需要关闭这个功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上面代码所示，通过 <code>format-detection</code> 这个 meta 字段，在 content 设置 <code>telephone=no</code>，来禁用 <code>mobile safari</code> 自动识别电话号码的功能。</p><p>另外，除了电话号码外，邮箱、地址、日期、链接这些字段也同样可以开启格式化保护：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"date=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"address=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"url=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者直接在 content 属性中，添加多个值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no, address=no, email=no, date=no, url=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做移动端页面的过程中，可能都遇到过 &lt;code&gt;moble safari&lt;/code&gt; 会自动识别一串数字为电话号码，并自动生成拨号的链接。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/telephone-no.jpg&quot; alt=&quot;拨号链接&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://www.wenkanglin.com/categories/html/"/>
    
      <category term="html-meta的学与记" scheme="http://www.wenkanglin.com/categories/html/html-meta%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="html-meta" scheme="http://www.wenkanglin.com/tags/html-meta/"/>
    
  </entry>
  
  <entry>
    <title>js对象的学与记：Object.freeze</title>
    <link href="http://www.wenkanglin.com/2018/05/02/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9AObject.freeze/"/>
    <id>http://www.wenkanglin.com/2018/05/02/js对象的学与记：Object.freeze/</id>
    <published>2018-05-02T09:11:53.000Z</published>
    <updated>2018-05-08T08:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，<code>es5</code>中新增了<code>Object.freeze</code>用来“冻结”对象的属性，阻止对象新增属性，修改属性的值，来达到类似于<code>writable: false</code>和<code>configurable: false</code>的效果。但是，要注意的是，对象中嵌套对象并不能被冻结。</p><a id="more"></a><p>例如，存在如下对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  type: &#123;</span><br><span class="line">    name: <span class="string">'lwk'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br></pre></td></tr></table></figure><p>其中，<code>obj.type</code>依旧可以添加属性，修改属性的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj.type.name = <span class="string">'lwk2'</span>;</span><br><span class="line">obj.newAttr = <span class="string">'001'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.type); <span class="comment">// &#123; name: 'lwk2', newAttr: '001' &#125;</span></span><br></pre></td></tr></table></figure><p>那么有什么办法，来真正实现对象的“冻结”呢？</p><p><img src="/images/sikao.jpg" alt="思考"></p><p>首先，先不妨思考一下，使用属性描述符<code>writable</code>和<code>configurable</code>是否可行？</p><p>答案是不可行，因为属性描述符虽然可以防止属性值被修改或删除，但不能阻止新增对象属性。</p><p>那么，<code>Object.seal</code>呢？</p><p>答案也是不行，因为<code>Object.seal</code>可以阻止新增对象属性，或者删除属性，但不能阻止修改属性值。</p><p>最终，我所能想到的是，递归调用<code>Object.freeze</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> freezeObject = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> &amp;&amp; <span class="built_in">Object</span>.freeze(obj[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，&lt;code&gt;es5&lt;/code&gt;中新增了&lt;code&gt;Object.freeze&lt;/code&gt;用来“冻结”对象的属性，阻止对象新增属性，修改属性的值，来达到类似于&lt;code&gt;writable: false&lt;/code&gt;和&lt;code&gt;configurable: false&lt;/code&gt;的效果。但是，要注意的是，对象中嵌套对象并不能被冻结。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wenkanglin.com/categories/javascript/"/>
    
      <category term="js对象的学与记" scheme="http://www.wenkanglin.com/categories/javascript/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="js对象" scheme="http://www.wenkanglin.com/tags/js%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>git的学与记：01</title>
    <link href="http://www.wenkanglin.com/2018/04/28/git%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9A01/"/>
    <id>http://www.wenkanglin.com/2018/04/28/git的学与记：01/</id>
    <published>2018-04-28T10:10:32.000Z</published>
    <updated>2018-05-08T08:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现经常遗忘常用的<code>git</code>命令操作，这里留一个笔记。</p><a id="more"></a><h2 id="一些名词解释"><a href="#一些名词解释" class="headerlink" title="一些名词解释"></a>一些名词解释</h2><ul><li><code>untracked files</code>字面意思是未跟踪的文件，表示之前从未提交过的文件，例如新建的文件。</li><li><code>unstaged files</code>表示那些之前提交过的文件，但目前已修改但未添加到提交列表里面的文件，即没有<code>git add</code>。</li><li>暂存区，指的是通过<code>git add</code>操作，把文件存放到暂存区。通过<code>git commit</code>把暂存区的所有修改提交到分支，而那些不在暂存区的修改并不能提交。</li></ul><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>通过<code>git init</code>把当前的项目设置为 git repo，生成<code>.git</code>文件夹。</p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>通过<code>git add</code>把文件添加到暂存区，如果想要添加一个已被忽略的文件，可以通过参数<code>-f</code>强制性添加忽略的文件，例如：<code>git add -f readme.txt</code>。</p><h2 id="git-commit-a"><a href="#git-commit-a" class="headerlink" title="git commit -a"></a>git commit -a</h2><p><code>git commit -a -m</code>相当于<code>git add .</code>和<code>git commit -m</code>，表示添加更改的文件并提交。但注意的是，对于<code>untracked files</code>来说无效。</p><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p><code>git status</code>可以查看当前状态，列出哪些是<code>untracked files</code>状态的文件，哪些是<code>not staged</code>的文件，哪些是<code>changes to be commited</code>（已添加但未提交的文件）。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   test.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use "git add &lt;file&gt;..." to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        test2.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></table></figure><p>这里表示，<code>test.txt</code>文件已添加(staged)，但未提交(commit)；<code>test2.txt</code>文件是未跟踪的文件，即新的文件；<code>readme.txt</code>是已修改，但未添加(unstaged)。</p><h2 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD "></a>git reset HEAD <file></file></h2><p><code>git reset HEAD</code>可以重置所有已添加(staged)的文件的状态为 unstaged，即取消<code>git add</code>。<code>&lt;file&gt;</code>表示可以指定特定的文件名，可以是多个文件名，用空格隔开。</p><h2 id="git-checkout-–"><a href="#git-checkout-–" class="headerlink" title="git checkout – "></a>git checkout – <file></file></h2><p><code>git checkout -- &lt;file&gt;</code>可以重置未添加(unstaged)但已修改(modified)的文件为未修改的状态。如果是已添加的文件(staged)，请使用<code>git reset HEAD</code>。可以使用<code>git checkout .</code>重置所有文件。</p><ul><li>一种是自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。而添加（新增）的文件，并不能还原。</p><p><code>git checkout src/*</code>可以使用类似于 glob 形式，把一个文件夹下面的修改文件重置。</p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>使用<code>git diff</code>查看和对比所有修改的内容。可以使用<code>git diff &lt;file&gt;</code>查看对比特定的文件内容。</p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>使用<code>git log</code>查看所有的提交记录，包括 commit id，提交信息，日期和作者，可以添加参数<code>--pretty=oneline</code>，简化显示提交记录，只单行显示 commit id 和提交信息。</p><p><code>git log --graph</code>可以查看分支合并图，从而基本了解分支提交合并的情况。</p><p><code>git log --abbrev-commit</code>会简化 commit id 成 6 位的形式。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>前面提到通过<code>git reset HEAD</code>来重置所有的 staged 状态的文件为 unstaged 状态。其中<code>HEAD</code>表示当前版本，也就是最新的提交。上一个版本就是<code>HEAD@{1}</code>，上上个版本就是<code>HEAD@{2}</code>，上 100 个版本就是<code>HEAD@{100}</code>。</p><p>所以，可以通过<code>git reset HEAD@{1} --hard</code>来回退到上一个版本，回退到上几个版本可以以此类推。</p><p>这样，就可以理解前面的<code>git reset HEAD</code>，表示回退到当前版本，可以起到<code>staged -&gt; unstaged</code>的作用了。</p><p>除了通过<code>HEAD</code>来回退版本之外，还可以通过具体的 commit id 来回退到某一个版本，例如<code>git reset --hard 3f23444cef0eeb9d32d1a9aded9808ac52b93589</code>。如果在回退到上一个版本的情况下，想要恢复到新版本的话，可以通过 commit id 来操作。</p><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><p>和<code>git log</code>不同的是，<code>git reflog</code>可以查看所有提交记录的 commit id，而<code>git log</code>不能查看回退到上一个版本后最新版本的 commit id。</p><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>通过<code>git rm</code>删除文件并提交到暂存区，注意的是物理删除，会直接从磁盘删除该文件。并且，要注意的是，如果在删除之前有修改的内容没有提交，删除之后恢复文件的话，只能恢复最新版本，修改的内容并不能还原。</p><p>不物理删除，可以通过<code>git rm -r --cached &lt;file&gt;</code>。该指令可以用在：要忽略之前已提交过的文件，这种情况下。所有的文件，可以通过<code>git rm -r --cached .</code>。</p><h2 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h2><p><code>git remote add origin git@xxxxx.git</code>，即把本地的仓库关联到远程仓库。</p><h2 id="git-upstream"><a href="#git-upstream" class="headerlink" title="git upstream"></a>git upstream</h2><p><code>git branch --set-upstream local_branch origin/origin_branch</code>可以把本地分支<code>local_branch</code>关联到远程分支<code>origin_branch</code>。也可以通过简写<code>-u</code>，例如：<code>git branch -u local_branch origin/origin_branch</code>。</p><p><code>git branch -u origin/dev</code>，会把当前所在的本地分支关联到远程分支上（前提是远程分支已经存在）。</p><p><code>git push -u origin master</code>，表示推送的同时，关联远程分支。</p><p><code>git branch --unset-upstream</code>取消当前分支的 upstream，即取消关联。</p><p><code>git branch --upset-upstream &lt;branch&gt;</code>取消特定分支的 upstream。</p><h2 id="查看-upstream"><a href="#查看-upstream" class="headerlink" title="查看 upstream"></a>查看 upstream</h2><p>可以在<code>.git/config</code>文件下面查看，或者<code>git remote show origin</code>。</p><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p><code>git branch</code>可以查看所有本地分支，展示如下（*符号表示当前分支）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch -a</code>可以查看所有的分支，包括本地和远程分支。</p><p><code>git branch 分支名</code>可以创建新的本地分支。</p><p><code>git branch -d 分支名</code>删除本地分支。</p><p><code>git branch -D 分支名</code>强行删除一个没有被合并过的分支。</p><p><code>git push -d origin dev</code>删除一个远程分支。</p><h2 id="git-checkout-分支"><a href="#git-checkout-分支" class="headerlink" title="git checkout 分支"></a>git checkout 分支</h2><p><code>git checkout dev</code>，把<code>HEAD</code>指向分支<code>dev</code>，即改变当前分支为<code>dev</code>（前提是<code>dev</code>分支存在）。</p><p><code>git checkout -b test</code>，创建分支<code>test</code>，并指向它，相当于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br><span class="line">git checkout test</span><br></pre></td></tr></table></figure><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p><code>git merge dev</code>，把本地分支<code>dev</code>的内容合并到当前分支（把 HEAD 指针指向<code>dev</code>）。</p><p><code>git merge origin/dev</code>，把远程分支<code>dev</code>的内容合并到当前分支。（建议使用这条指令合并，而不是上条）。</p><p>上面的合并，一般都是<code>Fast forward</code>模式，合并速度比较快。如果合并过程中，发现当前分支和被合并分支有一个文件都修改过，会进行智能合并，这个过程中，就不是<code>Fast forward</code>模式了。如果存在交叉情况，则会提示合并冲突，可以通过<code>git status</code>了解情况。</p><p>产生冲突的情况下，解决冲突后，继续<code>git add</code>和<code>git commit</code>。</p><p><code>git merge origin/dev --no-commit</code>合并时不自动提交。</p><h2 id="Fast-forward"><a href="#Fast-forward" class="headerlink" title="Fast forward"></a>Fast forward</h2><p>该合并模式下，合并分支之后把分支删除，则会丢掉分支信息。例如：<code>master</code>分支创建一个新的分支<code>dev</code>，通过<code>Fast forward</code>把<code>dev</code>分支合并到<code>master</code>中，然后删除<code>dev</code>分支，那么通过<code>git log --graph</code>就会查看不了<code>dev</code>分支的情况了。</p><p>可以使用<code>--nof-ff</code>，让不使用<code>Fast forward</code>模式，或者直接在 git 全局配置中默认禁用该模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config branch.master.mergeoptions "--no-ff"</span><br></pre></td></tr></table></figure><h2 id="git-pull-和-git-fetch"><a href="#git-pull-和-git-fetch" class="headerlink" title="git pull 和 git fetch"></a>git pull 和 git fetch</h2><p>两者不同之处在于，<code>git pull</code>相当于<code>git fetch</code> + <code>git merge</code>。</p><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p><code>git stash</code>把当前分支的所作修改存储起来，这样就可以去解决临时的其他问题。</p><p><code>git stash list</code>查看所有的的临时存储。</p><p><code>git stash apply</code>恢复最近入栈的存储，而且存储记录不会删除。</p><p><code>git stash apply stash@{n}</code>恢复指定的存储，同样存储记录不会删除。</p><p><code>git stash drop stash@{n}</code>删除一个存储记录，不加上<code>stash@{n}</code>的话，默认是删除<code>stash@{0}</code>。</p><p><code>git stash pop</code>恢复最近入栈的存储，并删除存储记录。</p><p><code>git stash pop stash@{n}</code>恢复指定存储，并删除。</p><p>注意，可以某些命令行，<code>stash@{n}</code>需要用双引号包裹起来。</p><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>通过<code>git tag v1.0.0</code>创建一个标签，使用<code>git tag</code>查看所有的标签。前面操作是对当前的 commit 打上标签。如果需要针对之前的提交打上标签，可以使用<code>git tag v1.0.0 commit-id</code>来完成。</p><p>通过<code>git show v1.0.0</code>来查看标签的信息。</p><p>通过<code>git tag -a v1.0.0 -m &quot;version 1.0.0 released&quot; commit-id</code>来创建带有描述的标签，其中<code>-m</code>指定说明文字。</p><p>通过<code>git tag -d v1.0.0</code>来删除本地标签。</p><p>通过<code>git push origin v1.0.0</code>把标签推送到远程，通过<code>git push origin --tags</code>一次推送所有未推送过的本地标签。</p><p>删除一个远程标签，可以先删除本地标签，然后通过<code>git push origin :refs/tags/v1.0.0</code>删除远程的标签。</p><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p><code>git config --global user.name wenkanglin</code>诸如此操作来设置 git 全局。然后可以通过<code>git config --list</code>列出所有已有的配置和配置值。</p><p>其中全局配置文件存放在<code>~用户名/.gitconfig</code>，项目的配置文件存放在项目的<code>.git/config</code>文件下。</p><h2 id="git-alias"><a href="#git-alias" class="headerlink" title="git alias"></a>git alias</h2><p>可以给<code>git status</code>中的<code>status</code>配置别名，其他命令也可以。通过<code>git config --global alias.st status</code>给<code>git status</code>配置了一个别名：<code>git st</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br></pre></td></tr></table></figure><h2 id="git-show-commit-id"><a href="#git-show-commit-id" class="headerlink" title="git show commit-id"></a>git show commit-id</h2><p>通过<code>git show 46508f9</code>来显示某次提交的具体信息（文件的增删改）。</p><h2 id="git-import-from-existing-git-repo"><a href="#git-import-from-existing-git-repo" class="headerlink" title="git import from existing git repo"></a>git import from existing git repo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin old-origin</span><br><span class="line">git remote add origin git@hszn1507-0029.sz.kingdee.net:yfe/test.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure><h2 id="只提交修改-删除的文件"><a href="#只提交修改-删除的文件" class="headerlink" title="只提交修改/删除的文件"></a>只提交修改/删除的文件</h2><p>通过<code>git add . --update</code>或者<code>git add . -u</code>，只会把修改的或者删除的文件提交到暂存区，新添加的文件不能被添加。</p><h2 id="git-add-–interactive-交互界面"><a href="#git-add-–interactive-交互界面" class="headerlink" title="git add –interactive 交互界面"></a>git add –interactive 交互界面</h2><p>通过<code>git add --interactive</code>或者<code>git add -i</code>进入交互界面，然后比如选择 2，或者 u，然后可以挑选你需要提交到缓存区的文件的序号。</p><h2 id="显示某个文件的提交历史记录"><a href="#显示某个文件的提交历史记录" class="headerlink" title="显示某个文件的提交历史记录"></a>显示某个文件的提交历史记录</h2><p>通过<code>git log --patch &lt;file&gt;</code>或者<code>git log -p &lt;file&gt;</code>来显示某一个文件的提交记录。</p><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>克隆仓库，并存放在指定路径下：<code>git clone @url &lt;path&gt;</code></p><p>克隆某个远程分支：<code>git clone -b branch @url</code>或者<code>git clone --branch branch @url</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现经常遗忘常用的&lt;code&gt;git&lt;/code&gt;命令操作，这里留一个笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://www.wenkanglin.com/categories/git/"/>
    
      <category term="git的学与记" scheme="http://www.wenkanglin.com/categories/git/git%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="git" scheme="http://www.wenkanglin.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo的学与记：命令</title>
    <link href="http://www.wenkanglin.com/2018/04/28/hexo%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9A%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.wenkanglin.com/2018/04/28/hexo的学与记：命令/</id>
    <published>2018-04-28T05:45:59.000Z</published>
    <updated>2018-05-08T08:41:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习和了解了<code>hexo</code>命令的前提下，写下来自己对这些配置命令的理解和使用说明。</p><a id="more"></a><h2 id="–config"><a href="#–config" class="headerlink" title="–config"></a>–config</h2><p>若不想默认使用<code>_config.yml</code>的配置的话，可以通过<code>--config</code>指定另外的配置文件，支持<code>yml</code>和<code>json</code>格式。并且，<code>--config</code>支持指定多个配置文件，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo serve --config config.json,config.yml</span><br></pre></td></tr></table></figure><p>如上面的情况下，后面的配置<code>config.yml</code>的优先级更高，会覆盖前面<code>config.json</code>存在相同的配置。最后，会自动生成<code>_multiconfig.yml</code>文件。</p><p>:warning: 指定多个配置的情况下，符号<code>,</code>两边不能留下空格。</p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>在<code>hexo</code>中，内置的<code>layout</code>有以下几种：</p><ul><li><strong>post</strong>: 默认值。若不指定<code>layout</code>的话，新建的<code>.md</code>文件将会放在<code>_posts</code>文件夹下面。</li><li><strong>draft</strong>: 从字面意思很容易理解，作为一种“草稿”，用于文章未完成阶段，且不想部署上去。<code>.md</code>文件将会放在<code>_drafts</code>文件夹下面。</li><li><strong>page</strong>: 创建时，文件结构不同于上面，会以<code>title</code>的名称创建一个文件夹，路径如<code>&lt;title&gt;/index.md</code>。</li></ul><p>可以修改默认的<code>layout</code>，只需配置<code>default_layout</code>，如设置默认为<code>draft</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_layout:</span> <span class="string">draft</span></span><br></pre></td></tr></table></figure><p>另外，<code>draft</code>草稿默认是不会被编译生成的。若需要展示草稿的话，需要配置<code>render_drafts</code>，如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">render_drafts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>或者在执行<code>hexo server</code>或者<code>hexo generate</code>命令时，使用<code>--draft</code>全局选项，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo s或者hexo serve或者hexo server是等价的</span></span><br><span class="line">hexo serve --draft</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo g是hexo generate的简写</span></span><br><span class="line">hexo g --draft</span><br></pre></td></tr></table></figure><p><code>layout</code>的值为<code>page</code>的情况下，假设<code>title</code>为<code>first-page</code>，生成的目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source</span><br><span class="line">└── first-page</span><br><span class="line">    └── index.md</span><br></pre></td></tr></table></figure><h2 id="global-options"><a href="#global-options" class="headerlink" title="global options"></a>global options</h2><p>常用的全局选项有以下：</p><ul><li><strong>–safe</strong>: 禁用所用的插件和脚本，可用于排查因插件而产生的问题。</li><li><strong>–debug</strong>: 使用调试模式，在控制台显示日志信息，并生成<code>debug.log</code>日志文件。</li><li><strong>–silent</strong>: 使用静默模式，不会在控制台显示任何信息。</li><li><strong>–draft</strong>: 展示<code>_drafts</code>中的草稿。</li></ul><h2 id="front-matter"><a href="#front-matter" class="headerlink" title="front-matter"></a>front-matter</h2><p><code>font-matter</code>的作用是展示博客文章的具体信息，放在<code>.md</code>文件的开头，信息包括：</p><ul><li><strong>layout</strong>: <a href="#layout">博客的<code>layout</code></a>。</li><li><strong>title</strong>: 博客的标题。</li><li><strong>date</strong>: 博客创建日期。</li><li><strong>updated</strong>: 博客最近更新的日期。</li><li><strong>comments</strong>: 是否开启博客评论的功能。</li><li><strong>tags</strong>: 博客的标签。</li><li><strong>categories</strong>: 博客的类目。</li><li><strong>permalink</strong>: 博客链接格式，将会覆盖配置文件中<code>permalink</code>的设置。</li></ul><p><code>font-matter</code>结合<code>hexo</code>的主题，可以在博客网站中清晰展示一篇文章的信息。有<code>yml</code>和<code>json</code>两种格式，推荐使用<code>yml</code>格式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">My</span> <span class="string">First</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-04</span><span class="bullet">-14</span> <span class="number">15</span><span class="string">:30:32</span></span><br><span class="line"><span class="attr">updated:</span> <span class="number">2018</span><span class="bullet">-04</span><span class="bullet">-15</span> <span class="number">12</span><span class="string">:01:31</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[tag1,</span> <span class="string">tag2,</span> <span class="string">tag3]</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category2</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">[category3,</span> <span class="string">subCategory]</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>如上面所示，<code>tags</code>和<code>categories</code>若是使用<code>yml</code>格式的话，可以是数组格式，也可以是列表格式。</p><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>通过<code>hexo help</code>获取命令和选项的列表。通过<code>hexo help &lt;command&gt;</code>获取具体某个命令的使用方式，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="built_in">help</span> publish</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt; [options]</span><br></pre></td></tr></table></figure><p>具体关于<code>layout</code>的信息，可以查看<a href="#layout">layout 介绍</a>。指定创建的文章的<code>layout</code>，可以如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft your-blog-title</span><br></pre></td></tr></table></figure><p>:warning: 关于<code>title</code>字段，需要注意的是，多个值最好不要通过空格隔开，虽然可以成功创建，但创建的文件会取最后一个值。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new my first blog</span><br></pre></td></tr></table></figure><p>上面的例子，创建的文件名称将会是<code>blog.md</code>，而不是<code>my-first-blog.md</code>。想要如预期处理，需要用字符串的形式。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"my first blog"</span></span><br></pre></td></tr></table></figure><p>关于<code>hexo new</code>命令中的<code>options</code>，有以下：</p><ul><li><strong>-p, –path</strong>: 设置创建的文章的路径和名称。</li><li><strong>-r, –replace</strong>: 如果创建的文章已存在，是否覆盖？</li><li><strong>-s, –slug</strong>: 设置创建的文章的文件名称。</li><li>可添加自定义的选项，并会显示在<a href="#front-matter">front-matter</a>。</li></ul><p>其中，关于<code>--path</code>和<code>--slug</code>，很容易让人迷糊。两者主要的区别，根据下面的例子就知道了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new hello-world --path parent/child</span><br></pre></td></tr></table></figure><p>上面的例子，文章最终创建的路径是<code>/source/_posts/parent/child.md</code>，文章标题是<code>hello-world</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new hello-world --slug parent/child</span><br></pre></td></tr></table></figure><p>而上面的例子，文章最终创建的路径是<code>/source/_posts/parent-child.md</code>，文章标题是<code>hello-world</code>。</p><p>关于第四点自定义选项，假设执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new hello-world --lang zh</span><br></pre></td></tr></table></figure><p>将会生成<code>hello-world.md</code>，并且文件头部的<code>front-matter</code>将会显示<code>lang</code>的信息，可能如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello-world</span><br><span class="line">date: 2018-04-15 14:45:20</span><br><span class="line">lang: zh</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>通过上面的命令，把位于<code>_drafts</code>下的博客文件，发布到<a href="#layout">layout</a>下面。其中若<code>layout</code>的值为<code>draft</code>，会被忽略，不会起到任何作用。如果未在<code>_drafts</code>文件夹下找到指定的<code>filename</code>，则报错。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment"># hexo generate的简写</span></span><br></pre></td></tr></table></figure><p>通过以上命令编译<code>source_dir</code>目录下面的文件，最终生成编译后的静态文件，并存放在<code>public_dir</code>目录下面。可使用<code>-d, --deploy</code>选项，相当于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d <span class="comment"># hexo deploy的简写</span></span><br></pre></td></tr></table></figure><p>通过以上命令，发布你的博客到远程仓库中。前提是你已经在<code>_config.yml</code>中配置好了<code>deploy</code>。可使用<code>-g, --generate</code>选项，发布博客前先构建，相当于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习和了解了&lt;code&gt;hexo&lt;/code&gt;命令的前提下，写下来自己对这些配置命令的理解和使用说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.wenkanglin.com/categories/hexo/"/>
    
      <category term="hexo的学与记" scheme="http://www.wenkanglin.com/categories/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://www.wenkanglin.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo的学与记：配置</title>
    <link href="http://www.wenkanglin.com/2018/04/28/hexo%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0%EF%BC%9A%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.wenkanglin.com/2018/04/28/hexo的学与记：配置/</id>
    <published>2018-04-28T05:44:55.000Z</published>
    <updated>2018-05-08T08:41:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>初次使用<code>hexo</code>配置自己的博客网站，接下来记录自己对于<code>hexo</code>配置作用的理解和说明。配合<a href="https://hexo.io/docs/" target="_blank" rel="noopener">hexo 文档</a>，一步一步配置自己的博客。</p><a id="more"></a><h2 id="language-和-timezone"><a href="#language-和-timezone" class="headerlink" title="language 和 timezone"></a>language 和 timezone</h2><p>国内的话，一般这样设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><p><code>language</code>字段可以配置多个值，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">[zh-CN,</span> <span class="string">en]</span></span><br></pre></td></tr></table></figure><p>另外，如果使用的<code>hexo</code>主题支持<code>i18n</code>的话，根据<code>language</code>的设置会自动切换相关的语言。</p><h2 id="permalink"><a href="#permalink" class="headerlink" title="permalink"></a>permalink</h2><p>若<code>permalink</code>中的某一个链接分割(segment)没有定义，那么值为<code>undefined</code>。比如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:lang/:title/</span></span><br></pre></td></tr></table></figure><p>上面示例中，显示的地址链接将会是<code>www.xxx.com/undefined/post-title</code>。</p><p>若<code>lang</code>定义但没有赋值，那么值会是<code>null</code>。比如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:lang/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">  lang:</span></span><br></pre></td></tr></table></figure><p>上面示例中，显示的地址链接将会是<code>www.xxx.com/null/post-title</code>。</p><p>可以设置空字符串，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:lang/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">  lang:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>上面的示例中，如果没有设置<a href="#front-matter">front-matter</a>，那么显示的地址链接将会是<code>www.xxx.com/post-title</code>。可是，需要注意的是，通过<code>hexo generate</code>生成页面时，因为是根据<code>permalink</code>动态生成目录结构，此时<code>lang</code>为空字符串，文件夹名称会自动转化为<code>null</code>。</p><p>:warning: <code>permalink</code>的末尾必须带上<code>/</code>，否则：</p><ul><li>通过<code>hexo serve</code>访问进去的不是博客页面，而是直接下载页面了。</li><li>通过<code>hexo generate</code>生成的不是<code>.html</code>文件，而是无后缀的文件。</li></ul><h2 id="permalink-defaults"><a href="#permalink-defaults" class="headerlink" title="permalink_defaults"></a>permalink_defaults</h2><p>从作用上来讲，<code>permalink_defaults</code>的作用主要有：</p><ul><li>设置<code>permalink</code>的默认值。</li><li>可添加自定义的<code>permalink</code>链接分割(segment)。</li></ul><p>例如，添加自定义的<code>lang</code>字段：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:lang/:title</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">  lang:</span> <span class="string">zh</span></span><br></pre></td></tr></table></figure><h2 id="skip-render"><a href="#skip-render" class="headerlink" title="skip_render"></a>skip_render</h2><p><code>skip_render</code>的主要作用是忽略渲染<code>source_dir</code>文件夹下面的被匹配文件，即在执行<code>hexo serve</code>或者<code>hexo generate</code>命令时，被匹配的文件不会被编译转化。根据文件的类型，会如下处理：</p><ul><li>若是匹配到了<code>.md</code>文件，则会忽略它们，不进行渲染编译。</li><li>若是匹配到了其他文件，例如<code>*.html</code>文件，则会复制它们到<code>public_dir</code>，否则会编译渲染。</li></ul><p>如果<code>skip_render</code>的值有<code>*</code>符号，则需要使用字符串的形式，否则报错。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">'**/*.md'</span></span><br></pre></td></tr></table></figure><p>如果<code>skip_render</code>的值是具体的路径名称，则不需要字符串。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">_post/index.html</span></span><br></pre></td></tr></table></figure><p>如果是多项值，可以是数组的形式，也可以是列表形式。例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">['**/*.&#123;md,html&#125;',</span> <span class="string">_post/test.md]</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'**/*.&#123;md,html&#125;'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">_post/test.md</span></span><br></pre></td></tr></table></figure><p>:warning: 如果发现<code>skip_render</code>作用效果无效，可以执行<code>hexo clean</code>，然后再尝试。</p><h2 id="index-generator"><a href="#index-generator" class="headerlink" title="index_generator"></a>index_generator</h2><p>首页配置，主要有：</p><ul><li><strong>path</strong>: 设置首页的路径，默认为空字符串。</li><li><strong>per_page</strong>: 设置首页博客文章每页显示的数量，设置<code>0</code>，是禁用分页功能。若设置为负数，将不能正常显示页面。默认为<code>10</code>。</li><li><strong>order_by</strong>: 博客文章排序方式，默认值是<code>-date</code>，即按最近日期依次排列。</li></ul><p>关于<code>path</code>，若设置不为空，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">'test'</span></span><br></pre></td></tr></table></figure><p>那么，首页路径将会是<code>http://domain.com/test</code>。这时需要注意的是直接访问<code>http://domain.com</code>将会访问不了页面。</p><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:wenkanglin/wenkanglin.github.io.git</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">':rocket: Site update on <span class="template-variable">&#123;&#123; now("YYYY-MM-DD HH:mm:ss") &#125;&#125;</span>'</span></span><br></pre></td></tr></table></figure><p>部署你的本地博客至远程仓库中，例如<code>git</code>。其中：</p><ul><li><strong>type</strong>: 指的是远程仓库的类型。</li><li><strong>repo</strong>: 远程仓库的地址。</li><li><strong>branch</strong>: 远程仓库的分支，默认是<code>master</code>分支。</li><li><strong>message</strong>: 提交时的消息，作用同等于<code>git commit -m</code>。</li></ul><p>:warning: 部署前根据类型需要安装依赖，例如<code>hexo-deployer-git</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初次使用&lt;code&gt;hexo&lt;/code&gt;配置自己的博客网站，接下来记录自己对于&lt;code&gt;hexo&lt;/code&gt;配置作用的理解和说明。配合&lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo 文档&lt;/a&gt;，一步一步配置自己的博客。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.wenkanglin.com/categories/hexo/"/>
    
      <category term="hexo的学与记" scheme="http://www.wenkanglin.com/categories/hexo/hexo%E7%9A%84%E5%AD%A6%E4%B8%8E%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://www.wenkanglin.com/tags/hexo/"/>
    
  </entry>
  
</feed>
